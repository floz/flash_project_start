/* ***** BEGIN LICENSE BLOCK *****
 * Copyright (C) 2007-2009 Digitas France
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * The Initial Developer of the Original Code is
 * Digitas France Flash Team
 *
 * Contributor(s):
 *   Digitas France Flash Team
 *
 * ***** END LICENSE BLOCK ***** */

package fr.digitas.flowearth.core {	/**	 * Liste contenant une collection d'objects toujours rangée.	 * La pile fonctionne un peu comme une displayList. A chaque ajout/suppression d'un object de la pile, les autre objects se deplacent afin de combler les vides	 * 	 * @example	 * exemple de _lab_/pile	 * <iframe style="height: 400px;" src="examples/pileIllustration.html"></iframe>	 * 
	 * @author Pierre Lepers
	 */
	public class Pile {
				/**		 * Contructeur		 * @param args Si un seul parametre de type Array est passé au contructeur, chaque object non null de cet Array est ajouté a la pile. Sinon chaque arguments est ajouté a la pile, dans l'ordre des arguments.		 */		public function Pile ( ...args ) {			init( args );		}				/**		 * renvoi une copy de l'Array interne de la Pile		 * @return Array une copie de la pile sous format Array		 */		public function array() : Array {			return new Array().concat( _items );			}				/**		 * renvoi un <code>Iterator</code> du contnu original de la pile		 */		public function getIterator () : IIterator {			return new Iterator( _items );			}			/**		 * Nombre d'object que contient la pile.		 */		public function get length() : uint {			return _items.length;			}				/**		 * Tri la pile de la meme façon que Array.sortOn();		 * @return une nouvelle pile triée si 4 ( Array.UNIQUESORT) ou 8 (Array.RETURNINDEXEDARRAY ) et passé en option. sinon renvoi null( la pile est directement modifiée)		 */		public function sortOn( names : *, options : uint = 0) : Pile {			var ret : Array = _items.sortOn( names, options );			if( ret ) return new Pile( ret );			return null;		}		/**		 * Ajoute un object a la pile.		 * <p>l'object est ajouté en haut de la pile et son index est renvoyé</p>		 * @param item l'object a ajouter a la pile		 * @return l'index de l'object ajouté dans la pile.		 */		public function addItem ( item : * ) : int {			return _items.push( item ) - 1;		}								/**		 * Ajoute un object a la pile a l'index voulu.		 * <p>si l'index est superieur a la taille de la pile, l'object est ajouté en haut de celle-ci. 		 * Sinon, les ojects situé au dessus de l'index son poussé d'un cran vers le haut.</p>		 * @param item l'object a ajouter a la pile		 * @param index position où ajouter l'object.		 */		public function addItemAt ( item : * , index : uint ) : void {			if( index >= _items.length  ) addItem( item );			else {				for( var i : Number = _items.length; i > index ; i-- ) _items[i] = _items[i - 1];				_items[ index ] = item;			} 		}								/**		 * Supprime un object de la pile. 		 * <p>Les object situé au dessus de lui descendent d'un cran pour combler le trou.</p>		 * @param item l'object a supprimer		 * @return index de l'object supprimer ou -1 si l'object n'existe pas dans la pile		 */		public function removeItem ( item : * ) : int {			var index : int = indexOf( item );			if( index > -1 ) {				removeItemAt( index );			}			return index;		}						/**		 * Supprime l'object situe a l'index dans la pile.		 *  		 * Les object situé au dessus de lui descendent d'un cran pour combler le trou. 		 * Si l'index est supperieur a la taille de la pile, rien n'est supprimé et la methode renvoi null.		 * @param index index de l'object a supprimer de la pile.		 * @return Object supprimé de la pile.		 */		public function removeItemAt ( index : uint ) : * {			if( index < _items.length ) {				var item : * = _items[index];				for( var i : Number = index; i < _items.length - 1 ; i++ ) _items[i] = _items[i+1];				_items.pop( );				return item;			}			return null;		}						/**		 * Deplace un object de la pile a l'index voulu.		 * <p>Si l'object n'existe pas dans la pile, nothing happen. si l'index est supperieur a la taille de la pile, il est ajouté en haut de celle ci.</p>		 * @param item object a deplacer		 * @param index nouvel index de l'object.		 */		public function setItemIndex ( item : * , index : uint ) : void {			if( indexOf( item ) == index ) return;			if( removeItem( item ) > -1 )				addItemAt( item, index );		}						/**		 * Inteverti la position de deux object dans la pile.		 * <p>Si l'un des object n'existe pas dans la pile, rien ne se passe.</p>		 * @param item1 object qui prend l'index de 'item2'		 * @param item2 object qui prend l'index de 'item1'		 */		public function swapItems ( item1 : *, item2 : * ) : void {			var i1 : int = indexOf( item1 );			var i2 : int = indexOf( item2 );			if( i1 != -1 && i2 != -1 ) {				_items[i1] = item2;				_items[i2] = item1;			}		}						/**		 * Interverti la position des objects situé aux index voulu		 * <p>Si un  des index est superieur a la taille de la pile, rien ne se passe</p>		 * @param index1 index du premier object a swaper		 * @param index2 index du deuxieme object a swaper		 */		public function swapItemsAt ( index1 : uint, index2 : uint ) : void {			//if( index1 < _items.length && index2 < _items.length ) {				var item2 : * = _items[index2];				_items[index2] = _items[index1];				_items[index1] = item2;			//}		}						/**		 * Renvoi l'index d'un object donné		 * <p>Si l'object n'existe pas dans la pile, la methode renvoi -1</p>		 * @param item object a chercher dans la pile		 * @param fromIndex parametre facutlatif. indique l'index de debut de recherche.		 * @return index de l'object a chercher, -1 si l'object n'existe pas dans la pile.		 */		public function indexOf ( item : *, fromIndex : int = 0 ) : int {			return _items.indexOf( item, fromIndex );		}						/**		 * Renvoi l'object situé a l'index donné.		 * <p>Si l'index est supperieur a la taille de la pile, la methode renvoi null.</p>		 * @param index index de l'object a recuperer		 * @return L'object trouvé a l'index donné, null si l'index est superieur a la taille de pile.		 */		public function getItemAt ( index : uint ) : * {			return _items[index];			//if( index < _items.length ) return _items[index];			//return null;		}				/**		 * remplace un item par un autre, rien se se passe si newItem est null;		 * @return true si l'ancien item a été trouvé et remplacer, false si rien n'a changé		 */		public function replaceItem( oldItem : *, newItem : * ) : Boolean {			if( oldItem === newItem || newItem == null) return false;			var index : int = _items.indexOf( oldItem );			if( index > - 1 ) _items[ index ] = newItem;			return ( index > - 1  );		}				public function toString() : String {			var str : String ="</br>*** Pile.toString *** </br>";			for( var i : String in _items ) {				str += _items[i]+ "</br>\n";			}			return str;		}				protected function init( args : Array ) : void {			_items = new Array();			var initArray : Array = ( args.length == 1 && args[0] is Array ) ? args[0] : args;			for each( var item : * in initArray ) if( item ) addItem(item);		}				protected var _items : Array;	}
}
